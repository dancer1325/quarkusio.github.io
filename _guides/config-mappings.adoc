////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
= Mapping configuration to objects
include::_attributes.adoc[]
:categories: core
:summary: Group multiple configuration properties into an object.
:numbered:
:sectnums:
:sectnumlevels: 4
:topics: configuration

* config mappings
    ** allows
        *** grouping MULTIPLE configuration properties | 1! interface / SAME prefix

[[config-mappings]]
== `@ConfigMapping`

* requirements
    ** üëÄpublic interface / `@io.smallrye.config.ConfigMapping` annotatedüëÄ

* if a mapping fails to match a configuration property -> throw `NoSuchElementException`
    ** OTHERWISE, the mapped element is `Optional`

=== Registration

* times / config mapping can be registered twice

==== STATIC INIT

* | Quarkus static initialization,
    ** Quarkus starts some of its services + `MicroProfile .Config`
    ** cases / ‚ùåNOT correctly initialize a config mapping‚ùå
        *** mapping requires `ConfigSource`'s values
            **** Solution: | config mapping, add `@io.quarkus.runtime.configuration.StaticInitSafe`

==== RUNTIME INIT

* happens AFTER _STATIC INIT_
* ‚ùåNO restrictions‚ùå

=== Retrieval

* ways to inject config mapping
    ** | CDI aware bean, -- via -- `@Inject`
    ** | non-CDI contexts, -- via -- API `io.smallrye.config.SmallRyeConfig#getConfigMapping`

[source,java]
----
SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);
Server server = config.getConfigMapping(Server.class);
----

=== Nested groups

* nested mapping
    ** allows
        *** subgrouping OTHER config properties

=== Overriding property names

==== `@WithName`

If a method name, or a property name do not match with each other, the `@WithName` annotation can override the method
name mapping and use the name supplied in the annotation:

[source,java]
----
@ConfigMapping(prefix = "server")
public interface Server {
    @WithName("name")
    String host();

    int port();
}
----

.application.properties
[source,properties]
----
server.name=localhost
server.port=8080
----

==== `@WithParentName`

The `@WithParentName` annotation allows to configurations mapping to inherit its container name, simplifying the
configuration property name required to match the mapping:

[source,java]
----
interface Server {
    @WithParentName
    ServerHostAndPort hostAndPort();

    @WithParentName
    ServerInfo info();
}

interface ServerHostAndPort {
    String host();

    int port();
}

interface ServerInfo {
    String name();
}
----

.application.properties
[source,properties]
----
server.host=localhost
server.port=8080
server.name=konoha
----

Without the `@WithParentName` the method `name()` requires the configuration property `server.info.name`. Because we use
`@WithParentName`, the `info()` mapping will inherit the parent name from `ConvertWithOptional` and `name()` maps to `server.name`
instead.

==== NamingStrategy

Method names in camelCase map to kebab-case property names:

[source,java]
----
@ConfigMapping(prefix = "server")
public interface Server {
    String theHost();

    int thePort();
}
----

.application.properties
[source,properties]
----
server.the-host=localhost
server.the-port=8080
----

The mapping strategy can be adjusted by setting `namingStrategy` value in the `@ConfigMapping` annotation:

[source,java]
----
@ConfigMapping(prefix = "server", namingStrategy = ConfigMapping.NamingStrategy.VERBATIM)
public interface ServerVerbatimNamingStrategy {
    String theHost();

    int thePort();
}
----

.application.properties
[source,properties]
----
server.theHost=localhost
server.thePort=8080
----

The `@ConfigMapping` annotation support the following naming strategies with the following enum values:

- `KEBAB_CASE` (default) - The method name is derived by replacing case changes with a dash to map the configuration property, i.e. `theHost` maps to `the-host`.
- `VERBATIM` - The method name is used as is to map the configuration property, i.e. `theHost` maps to `theHost`.
- `SNAKE_CASE` - The method name is derived by replacing case changes with an underscore to map the configuration property, i.e. `theHost` maps to `the_host`.

=== Conversions

* config mapping
    ** convert AUTOMATICALLY ALL types / convert `MicroProfile.Config`
        *** ALSO valid -- for -- `Optional`

==== `@WithConverter`

The `@WithConverter` annotation provides a way to set a `Converter` to use in a specific mapping:

[source,java]
----
@ConfigMapping
public interface Converters {
    @WithConverter(FooBarConverter.class)
    String foo();
}

public static class FooBarConverter implements Converter<String> {
    @Override
    public String convert(final String value) {
        return "bar";
    }
}
----

.application.properties
[source,properties]
----
foo=foo
----

A call to `Converters.foo()` results in the value `bar`.

==== Collections ====

A config mapping is also able to map collections types `List` and `Set`:

[source,java]
----
@ConfigMapping(prefix = "server")
public interface ServerCollections {
    Set<Environment> environments();

    interface Environment {
        String name();

        List<App> apps();

        interface App {
            String name();

            List<String> services();

            Optional<List<String>> databases();
        }
    }
}
----

.application.properties
[source,properties]
----
server.environments[0].name=dev
server.environments[0].apps[0].name=rest
server.environments[0].apps[0].services=bookstore,registration
server.environments[0].apps[0].databases=pg,h2
server.environments[0].apps[1].name=batch
server.environments[0].apps[1].services=stock,warehouse
----

The `List` or `Set` mappings can use xref:config-reference.adoc#indexed-properties[indexed properties] to map
configuration values in mapping groups. For collection with simple element types like `String`, their configuration
value is a comma separated string.

NOTE: Only the `List` mapping can maintain element order. Hence, with `Set` mappings the element order is not maintained from the configuration files but is random.

==== Maps ====

* ALLOWED |
    ** map
    ** groups


[source,java]
----
@ConfigMapping(prefix = "server")
public interface Servers {
    @WithParentName
    Map<String, Server> allServers();
}

public interface Server {
    String host();

    int port();

    String login();

    String error();

    String landing();
}
----
.application.properties
[source,properties]
----
server."my-server".host=localhost
server."my-server".port=8080
server."my-server".login=login.html
server."my-server".error=error.html
server."my-server".landing=index.html
----
In this case the `allServers()` `Map` will
contain one `ConvertWithOptional` element with the key `my-server`.

=== Defaults

The `@WithDefault` annotation allows to set a default property into a mapping (and prevent and error if the
configuration value is not available in any `ConfigSource`):

[source,java]
----
public interface Defaults {
    @WithDefault("foo")
    String foo();

    @WithDefault("bar")
    String bar();
}
----

No configuration properties required. The `Defaults.foo()` will return the value `foo` and `Defaults.bar()` will return
the value `bar`.

=== Validation

A config mapping may combine annotations from https://beanvalidation.org[Bean Validation] to validate configuration
values:

[source,java]
----
@ConfigMapping(prefix = "server")
public interface Server {
    @Size(min = 2, max = 20)
    String host();

    @Max(10000)
    int port();
}
----

WARNING: For validation to work, the `quarkus-hibernate-validator` extension is required, and it is performed
automatically.

=== Mocking

A mapping interface implementation is not a proxy, so it cannot be mocked directly with `@InjectMock` like other CDI
beans. One trick is to make it proxyable with a producer method:

[source,java]
----
public class ServerMockProducer {
    @Inject
    Config config;

    @Produces
    @ApplicationScoped
    @io.quarkus.test.Mock
    Server server() {
        return config.unwrap(SmallRyeConfig.class).getConfigMapping(Server.class);
    }
}
----

The `ConvertWithOptional` can be injected as a mock into a Quarkus test class with `@InjectMock`:

[source,java]
----
@QuarkusTest
class ServerMockTest {
    @InjectMock
    Server server;

    @Test
    void localhost() {
        Mockito.when(server.host()).thenReturn("localhost");
        assertEquals("localhost", server.host());
    }
}
----

NOTE: The mock is just an empty shell without any actual configuration values.

If the goal is to only mock certain configuration values and retain the original configuration, the mocking instance
requires a spy:

[source,java]
----
@ConfigMapping(prefix = "app")
public interface AppConfig {
    @WithDefault("app")
    String name();

    Info info();

    interface Info {
        @WithDefault("alias")
        String alias();
        @WithDefault("10")
        Integer count();
    }
}

public static class AppConfigProducer {
    @Inject
    Config config;

    @Produces
    @ApplicationScoped
    @io.quarkus.test.Mock
    AppConfig appConfig() {
        AppConfig appConfig = config.unwrap(SmallRyeConfig.class).getConfigMapping(AppConfig.class);
        AppConfig appConfigSpy = Mockito.spy(appConfig);
        AppConfig.Info infoSpy = Mockito.spy(appConfig.info());
        Mockito.when(appConfigSpy.info()).thenReturn(infoSpy);
        return appConfigSpy;
    }
}
----

The `AppConfig` can be injected as a mock into a Quarkus test class with `@Inject`:

[source,java]
----
@QuarkusTest
class AppConfigTest {
    @Inject
    AppConfig appConfig;

    @Test
    void localhost() {
        Mockito.when(appConfig.name()).thenReturn("mocked-app");
        assertEquals("mocked-app", server.host());

        Mockito.when(appConfig.info().alias()).thenReturn("mocked-alias");
        assertEquals("mocked-alias", server.info().alias());
    }
}
----

NOTE: Nested elements need to be spied individually by Mockito.
