////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
= Mutiny - Async for mere mortals
include::_attributes.adoc[]
:categories: reactive
:topics: mutiny,reactive
:extensions: io.quarkus:quarkus-mutiny
:imagesdir: ./images

* https://smallrye.io/smallrye-mutiny[Mutiny]
    ** == programming library
        *** intuitive
        *** reactive
        *** event-driven
    ** uses
        *** write reactive applications | Quarkus

== An event-driven reactive programming API

* event-driven
    ** == you receive events & you react to them
    ** use cases
        *** distributed systems

* üëÄprovided typesüëÄ /
    ** event-driven & lazy (-> event sources)
        *** `Uni`
            **** emits 1! event (item OR failure)
            **** use cases
                ***** asynchronous actions / return 0 OR 1
                    ****** _Example:_ send a message -- to a -- message broker queue
        *** `Multi`
            **** emits multiple events (TODO: n items, 1 failure or 1 completion)
            **** use cases
                ***** streams of items (even unbounded)
                     ****** _Example:_ receive messages -- from a -- message broker queue

* event sources
    ** == you observe them (_subscription_) + | emit an item, failure, or completion event (bounded Multi), you get notified
        *** if the subscriber receives the event -> can process it (_Examples:_ transform it, filter it)

== Mutiny in Quarkus

* üëÄMOST Quarkus extensions
    ** support MutinyüëÄ -- by --
        *** exposing an API / return Unis and Multis (_Examples:_ reactive data sources or rest clients) OR
        *** understanding when your methods return a Uni or Multi (_Example:_ Quarkus REST or Reactive Messaging)

* allows
    ** eliminating dead-code -> less memory usage
        *** Reason: üß†Mutiny architectureüß† 

* xref:quarkus-reactive-architecture.adoc#engine[Quarkus reactive engine]

== Why another reactive programming API?

* vs other reactive programming libraries
    ** ‚ö†Ô∏è| design your program, different approach‚ö†Ô∏è
        *** <<an-event-driven-reactive-programming-api,Event-Driven>>
        *** **Navigable**
            **** == drive you towards the operator / you need
        *** **Non-Blocking I/O**
            **** -> powers xref:quarkus-reactive-architecture.adoc[Quarkus reactive architecture]
        *** **It can be used | any asynchronous application**
            **** _Examples:_ event-driven microservices, message-based applications, network utilities, data stream processing, reactive applications, ...
        *** **Reactive Streams and Converters Built-In**
            **** it can be integrated -- with -- any other reactive programming library
                ***** Reason:üß†Mutiny is based -- on the -- https://www.reactive-streams.org/[Reactive Streams specification]üß†

== Mutiny and the I/O Threads

* | reactive application
    ** code is executed | one of the FEW I/O threads
    ** recommendations
        *** ‚ùåNEVER block these threads‚ùå
            **** Reason:üß†otherwise, the model would collapseüß†
            **** == ‚ùåNOT use blocking I/O‚ùå
        *** schedule the I/O operation + pass a continuation

image::reactive-thread.png[alt=Reactive Execution Model and I/O Threads,width=50%, align=center]

* Mutiny event-driven paradigm
    ** tailored for: schedule the I/O operation + pass a continuation
When the I/O operation completes successfully, the Uni that represents it emits an item event.
When it fails, it emits a failure event.
The continuation is simply and naturally expressed using the event-driven API.

== Mutiny through Examples

In the initialize method, we retrieve and store the collection in which elements will be inserted.

The `add` method inserts an element in the collection.
It receives the element as a parameter and uses the reactive API of the collection.
Interacting with the database involves I/Os.
The reactive principles forbid blocking while waiting for the interaction to complete.
Instead, we schedule the operation and pass a continuation.
The `insertOne` method returns a Uni, i.e., an asynchronous operation.
That's the scheduled I/O. We now need to express the continuation, which is done using the `.onItem()` method.
`.onItem()` allows configuring what needs to happen when the observed Uni emits an item, in our case when the scheduled I/Os completes.
In this example, we extract the inserted document id.
The final step is the subscription.
Without it, nothing would ever happen. Subscribing triggers the operation.
The subscription method can also define handlers:  the `id` value on success, or a failure when the insertion fails.

Let's now look at the second method.
It retrieves all the stored elements.
In this case, it returns multiple items (one per stored element), so we are using a `Multi`.
As for the insertion, getting the stored elements involves I/Os.
The `find` is our operation.
As for Uni, you need to subscribe to trigger the operation.
The subscriber receives item events, a failure event, or a completion event when all the elements have been received.

Subscribing to a Uni or a Multi is essential, as without it, the operation is never executed.
In Quarkus some extensions deal with the subscription for you.
For example, in Quarkus REST your HTTP methods can return a Uni or a Multi, and Quarkus REST handles the subscription.

== Mutiny Patterns

The example from the last section was simplistic on purpose.
Let's have a look at a few common patterns.

=== Observing events

You can observe the various kind of events using:

`on{event}().invoke(ev -> System.out.println(ev));`

For example, for items use:
`onItem().invoke(item -> ...);`

For failure, use:
`onFailure().invoke(failure -> ...)`

The `invoke` method is synchronous.
Sometimes you need to execute an asynchronous action.
In this case use `call`, as in: `onItem().call(item -> someAsyncAction(item))`.
Note that `call` does not change the item, it just calls an asynchronous action, and when this one completes, it emits the original item downstream.

=== Transforming item

The first instrumental pattern consists of transforming the item events you receive.
As we have seen in the previous section, it could indicate the successful insertion, or the elements stored in the database.

Transforming an item is done using: `onItem().transform(item -> ....)`.

More details about transformation can be found in the https://smallrye.io/smallrye-mutiny/latest/tutorials/transforming-items/[Mutiny documentation].

=== Sequential composition

Sequential composition allows chaining dependent asynchronous operations. This is achieved using `onItem().transformToUni(item -> ...)`.
Unlike `transform`, the function passed to `transformToUni` returns a Uni.

[source, java]
----
Uni<String> uni1 = ‚Ä¶
uni1
.onItem().transformToUni(item -> anotherAsynchronousAction(item));
----

More details about asynchronous transformation can be found in the https://smallrye.io/smallrye-mutiny/latest/tutorials/transforming-items-asynchronously/[Mutiny documentation].

=== Failure handling

So far we only handle the item events, but handling failure is essential. You can handle failures using `onFailure()`.

For example, you can recover with a fallback item using `onFailure().recoverWithItem(fallback)`:

[source, java]
----
Uni<String> uni1 = ‚Ä¶
uni1
.onFailure().recoverWithItem(‚Äúmy fallback value‚Äù);
----

You can also retry the operation such as in:

[source, java]
----
Uni<String> uni1 = ‚Ä¶
uni1
.onFailure().retry().atMost(5);
----

More info about failure recovery can be found on https://smallrye.io/smallrye-mutiny/latest/tutorials/handling-failures/[the handling failure documentation] and https://smallrye.io/smallrye-mutiny/latest/tutorials/retrying/[the retrying on failures documentation].

== Events and Actions

The following tables list the events that you can receive for Uni and Multi. Each of them is associated with its own group (onX). The second table lists the classic action you can do upon an event. Note that some groups offer more possibilities.



|===
| |Events from the upstream |Events from the downstream

|Uni
|Subscription (1), Item (0..1), failure (0..1)
|Cancellation

|Multi
|Subscription (1), Item (0..n), failure (0..1), completion (0..1)
|Cancellation, Request
|===

Check the full list of events on https://smallrye.io/smallrye-mutiny/latest/tutorials/observing-events/[the event documentation].

|===
| Action |API |Comment

|transform | `onItem().transform(Function<I, O> function);` | Transform the event into another event using a synchronous function.
The downstream receives the result of the function (or a failure if the transformation failed).
|transformToUni | `onItem().transformToUni(Function<I, Uni<O>> function);` | Transform the event into another event using an asynchronous function. The downstream receives the item emitted by the produced Uni (or a failure if the transformation failed). If the produced Uni emits a failure, that failure is passed to the downstream.
|invoke | `onItem().invoke(Consumer<I> consumer)` | Invokes the synchronous consumer. This is particularly convenient to execute side effects actions. The downstream receives the original event, or a failure if the consumer throws an exception
| call | `onItem().call(Function<I, Uni<?>>)` | Invokes the asynchronous function. This is particularly convenient to execute asynchronous side effect actions.The downstream receives the original event, or a failure if the consumer throws an exception or if the produced Uni emits a failure.
| fail | `onItem().failWith(Function<I, Throwable>)` | Emits a failure when it receives the event.
| complete (Multi only) | `onItem().complete()` | Emits the completion event when it receives the event.
|===

=== Other patterns

Mutiny provides lots of other features.
Head over to the https://smallrye.io/smallrye-mutiny[Mutiny documentation] to see many more examples, including the whole list of events and how to handle them.

Some frequently asked guides are the following:

1. merge vs. concatenation - https://smallrye.io/smallrye-mutiny/latest/guides/merging-and-concatenating-streams/
2. controlling the emission thread - https://smallrye.io/smallrye-mutiny/latest/guides/emit-on-vs-run-subscription-on/
3. explicit blocking  - https://smallrye.io/smallrye-mutiny/latest/guides/imperative-to-reactive/

== Shortcuts

When using Uni, having to write `onItem()` can be cumbersome.
Fortunately, Mutiny provides a set of shortcut to make your code more concise:


|===
|Shortcut | Equivalent

|`uni.map(x -> y)`
|`uni.onItem().transform(x -> y)`

|`uni.flatMap(x -> uni2)`
|`uni.onItem().transformToUni(x -> uni2)`

|`uni.chain(x -> uni2)`
|`uni.onItem().transformToUni(x -> uni2)`

|`uni.invoke(x -> System.out.println(x))`
|`uni.onItem().invoke(x -> System.out.println(x))`

|`uni.call(x -> uni2)`
|`uni.onItem().call(x -> uni2)`

|`uni.eventually\(() -> System.out.println("eventually"))`
|`uni.onItemOrFailure().invoke\((ignoredItem, ignoredException) -> System.out.println("eventually"))`

|`uni.eventually(() -> uni2)`
|`uni.onItemOrFailure().call((ignoredItem, ignoredException) -> uni2)`

|`uni.replaceWith(x)`
|`uni.onItem().transform(ignored -> x)`

|`uni.replaceWith(uni2)`
|`uni.onItem().transformToUni(ignored -> uni2)`

|`uni.replaceIfNullWith(x)`
|`uni.onItem().ifNull().continueWith(x)`
|===

== Reactive Streams

Mutiny uses https://www.reactive-streams.org/[Reactive Streams].
`Multi` implements `Publisher` and enforces the back-pressure protocol.
Emissions are constrained by the request emitted from the downstream subscribers.
Thus, it does not overload the subscribers.
Note that in some cases, you can‚Äôt follow this protocol (because the Multi emits events that can‚Äôt be controlled, such as time, or measures sensors).
In this case, Mutiny provides a way to control the overflow using `onOverflow()`.

`Uni` does not implement Reactive Streams `Publisher`.
A `Uni` can only emit one event, so subscribing to the `Uni` is enough to express your intent to use the result and does not need the request protocol ceremony.

== Mutiny and Vert.x

Vert.x is a toolkit to build reactive applications and systems.
It provides a huge ecosystem of libraries following the reactive principles (i.e., non-blocking and asynchronous).
Vert.x is an essential part of Quarkus, as it provides its reactive capabilities.

In addition, the whole Vert.x API can be used with Quarkus.
To provide a cohesive experience, the Vert.x API is also available using a Mutiny variant, i.e., returns Uni and Multi.

More details about this API can be found on: https://quarkus.io/blog/mutiny-vertx/.

== Mutiny Integration in Quarkus

The integration of Mutiny in Quarkus goes beyond just the library.
Mutiny exposes hooks that allow Quarkus and Mutiny to be closely integrated:

* Calling `await` or `toIterable` would fail if you are running on an I/O thread, preventing blocking the I/O thread;
* The `log()` operator use the Quarkus logger;
* The default Mutiny thread pool is the Quarkus worker thread pool;
* Context Propagation is enabled by default when using Mutiny Uni and Multi

More details about the infrastructure integration can be found on https://smallrye.io/smallrye-mutiny/latest/guides/framework-integration/.




