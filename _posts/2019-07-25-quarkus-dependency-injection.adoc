---
layout: post
date:   2019-07-25 00:00 +0100
author: mkouba
tags: extension arc development-tips 
synopsis: Quarkus ArC is a build-time oriented dependency injection based on CDI 2.0. But what does it actually mean and what benefits does a build-time processing DI bring?
---

= Quarkus Dependency Injection

* goal
    ** Quarkus ArC
        *** vs CDI spec
        *** benefits & drawbacks

* Quarkus ArC
    ** == ðŸ’¡dependency injectionðŸ’¡
        *** build-time oriented
        *** -- based on -- http://cdi-spec.org/[CDI 2.0]
            **** âŒNOT FULL CDI implementationâŒ
                ***** https://quarkus.io/guides/cdi-reference#supported_features[supported features]
                ***** https://quarkus.io/guides/cdi-reference#limitations[limitations]

== Compatibility

* Quarkus DI
    ** built | CDI
        *** Reasons:ðŸ§ 
            1. CDI is mature & proven component model
            2. 10 years of experience developing http://weld.cdi-spec.org/[Weld - the CDI Reference Implementation]
            3. CDI API is built | `javax.inject`
                **** -> easy to migrate from any DI framework / compatible with `@Inject`
    ** 's primary goal
        *** DI solution /
            **** supersonic build-time oriented
            **** compatible -- with -- CDI

== Build-time Processing Benefits and Drawbacks

=== Fail Fast

* | build,
    ** validate beans and dependencies
        *** -> | production, NO errors as `AmbiguousResolutionException` or `UnsatisfiedResolutionException`

=== Instant Startup

* | starts the app,
    ** ArC
        *** loads ALL the metadata
        *** initializes some internal structures
    ** _Examples:_ GraalVM & OpenJDK HotSpot runtimes

=== Minimized Runtime

* | Quarkus 0.19,
    ** ArC plus integration runtime
        *** == 72 classes
        *** ~ 140 KB (jars)
            **** == 7% of the Weld runtime

* http://weld.cdi-spec.org/[Weld 3.1.1]'s core
    ** == 1200 classes
    ** 2 MB (jar)

=== Optimized Code Paths and Metadata Structures

* | generate the metadata classes,
    ** ArC can sometimes produce leaner & smarter logic
        *** Reason:ðŸ§  it has ALREADY the whole application analyzedðŸ§ 

=== Extension Points

* CDI portable extensions
    ** âŒNOT FULLY supported | QuarkusâŒ
        *** Reason: ðŸ§ are runtime constructsðŸ§ 
        *** ALTERNATIVE: -- via -- https://quarkus.io/guides/cdi-reference#build-time-extension-points[Quarkus extensions]

== Non-standard Features

* ArC
    ** go beyond the standards
        *** âŒNOT limited to standardsâŒ

=== Qualified Injected Fields

* `@Inject`
    ** | constructor & method injection,
        *** âš ï¸MANDATORYâš ï¸
    ** | injected field declaration
        *** if there are >= 1 qualifier -> you can skip it
        *** OTHERWISE, MANDATORY

=== Simplified Constructor Injection

* TODO: In CDI, a normal scoped bean must always declare a no-args constructor (this constructor is normally generated by the compiler unless you declare any other constructor).
However, this requirement complicates constructor injection - you would need to provide a dummy no-args constructor to make things work in CDI.

[source,java]
----
@ApplicationScoped
public class MyCoolService {

  private SimpleProcessor processor;

  MyCoolService() { // dummy constructor needed
  }
  
  @Inject // constructor injection
  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
----

There is no need to declare dummy constructors for normal scoped bean in Quarkus - they are generated automatically.
Also if there's only one constructor there is no need for `@Inject`.

[source,java]
----
@ApplicationScoped
public class MyCoolService {

  private SimpleProcessor processor;

  MyCoolService(SimpleProcessor processor) {
    this.processor = processor;
  }
}
----

NOTE: We don't generate a no-args constructor automatically if a bean class extends another class that does not declare a no-args constructor.

=== Default Beans

CDI has a feature called https://docs.jboss.org/cdi/spec/2.0/cdi-spec.html#alternatives[alternatives].
Simply said a bean annotated with `@Alternative` and `@Priority` takes precedence over the non-alternative beans during type-safe resolution.

[source,java]
----
class MyBean {
}

@Alternative
@Priority(1)
class MyAlternativeBean extends MyBean {
}

@Inject // MyAlternativeBean wins and is injected!
MyBean bean;
----

So, what if a user wants to override a bean defined by a library/extension? 
The bean would have to be marked as a CDI `@Alternative` that is enabled using the `@Priority` annotation.
Is there a simpler approach?
Yes, there is.
You can use a non-standard feature called "default beans".
In this case, a bean that can be overridden should be annotated with `@io.quarkus.arc.DefaultBean`.
And that's it.

[source,java]
----
@DefaultBean
class MyBean {
}

class MyOwnBean extends MyBean {
}

@Inject // MyOwnBean wins and is injected!
MyBean bean;
----

=== Removing Unused Beans

GraalVM native image does a pretty good job when removing all classes that are not reachable from your application.
However, sometimes checking reachability is not enough.
Sometimes the framework itself must decide whether a component is needed or not.
In standard CDI, all beans are retained by the container no matter whether they're needed or not.

Let's suppose we have a bean class `org.acme.Foo`.
This bean class imports and uses a lot of various classes.
It's annotated with `@ApplicationScoped` and so Quarkus needs to generate a bean metadata class and a client proxy and register this metadata when the application starts.
But what if nobody ever uses this bean?
We would still hold a reference on the generated metadata, and the bean class itself, and its dependencies. 
In other words, all these classes would be reachable.

Quarkus attempts to remove all *unused beans* during build by default.
This helps to reduce the number of generated classes and also the amount of memory needed at runtime.
But how do we actually detect an unused bean?
The rules are described in the https://quarkus.io/guides/cdi-reference#remove_unused_beans[reference guide] but simply said: if a bean is not injected anywhere and cannot be reached in any other standard way (e.g. observer notification) it is removed.
Moreover, users can instruct the container to not remove a bean by annotating the bean class with `@io.quarkus.arc.Unremovable`.
Finally, this optimization can be disabled and fine tuned by using the `quarkus.arc.remove-unused-beans` property. 

NOTE: This feature applies to the JVM mode as well.
